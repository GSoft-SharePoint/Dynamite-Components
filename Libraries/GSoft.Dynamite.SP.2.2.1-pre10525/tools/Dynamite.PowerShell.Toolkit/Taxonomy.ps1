#
# Module 'Dynamite.PowerShell.Toolkit'
# Generated by: GSoft, Team Dynamite.
# Generated on: 10/24/2013
# > GSoft & Dynamite : http://www.gsoft.com
# > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
# > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
#

<#
	.SYNOPSIS
		Commandlet to retrieve an object of type Microsoft.SharePoint.Taxonomy.TaxonomySession.

	.DESCRIPTION
		Commandlet to get an object of type Microsoft.SharePoint.Taxonomy.TaxonomySession for the site passed in the site parameter.
		If no site is passed the Central Administration will be used by default.

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
		
	.PARAMETER Site
		The Site Collection for wich the Taxonomy Session is related. The central Administration is used by default.
		
	.EXAMPLE
		PS C:\> Get-DSPTaxonomySession -Site "http://example.com"

	.OUTPUTS
		Microsoft.SharePoint.Taxonomy.TaxonomySession  
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Get-DSPTaxonomySession()
{
	Param(
		[Parameter(Mandatory=$false, ValueFromPipeline=$true)]
		[Microsoft.SharePoint.PowerShell.SPSitePipeBind]$Site = $(
			$defaultSite = @(Get-SPWebApplication -IncludeCentralAdministration | Where {$_.IsAdministrationWebApplication})[0].Url
			new-object Microsoft.SharePoint.PowerShell.SPSitePipeBind($defaultSite)
		)
	)
	
	$session = new-object Microsoft.SharePoint.Taxonomy.TaxonomySession($Site.Read())
  return $session
}

<#
	.SYNOPSIS
		Commandlet to retrieve an object of type Microsoft.SharePoint.Taxonomy.TermStore.

	.DESCRIPTION
		Commandlet to get an object of type Microsoft.SharePoint.Taxonomy.TermStore from the Taxonomy Session passed in parameter.
		If no Taxonomy Session is passed the Central Administration will be used by default. If the default switch is used, the first
		Term Store found will be returned. Specifing the Id or Name will return the Term Store for that Id or Name.

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
		
	.PARAMETER TaxonomySession
		The Taxonomy Session where we can find the Term Store.
	
	.PARAMETER Default
		Returns the first Term Store found.
		
	.PARAMETER Name
		Returns the Term Store with that name.
	
	.PARAMETER Id
		Returns the Term Store with that GUID.
		
	.EXAMPLE
		PS C:\> Get-DSPTermStore -Default

	.OUTPUTS
		Microsoft.SharePoint.Taxonomy.TermStore  
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Get-DSPTermStore()
{
	Param(
		[Parameter(Mandatory=$false, ValueFromPipeline=$true)]
		[Microsoft.SharePoint.Taxonomy.TaxonomySession]$TaxonomySession = $(Get-DSPTaxonomySession),
		
		[Parameter(Mandatory=$true, ParameterSetName="default")]
		[switch]$Default,
		
		[Parameter(Mandatory=$true, ParameterSetName="ByName")]
		[string]$Name,
		
		[Parameter(Mandatory=$true, ParameterSetName="ById")]
		[string]$Id
	)
	
	switch($PsCmdlet.ParameterSetName)
	{
		"ByName" {
			$identifier = $Name
		}
		
		"ById" {
			$identifier = $Id
		}
		
		"default" {
			$serviceApp = (Get-SPServiceApplicationProxy | Where {$_.GetType().Name -eq "MetadataWebServiceApplicationProxy"})[0]
			$identifier = $serviceApp.Name
		}
	}
	  
  $termStore = $TaxonomySession.TermStores[$identifier]
  return $termStore;
}

<#
	.SYNOPSIS
		Commandlet to retrieve an object of type Microsoft.SharePoint.Taxonomy.TermSet.

	.DESCRIPTION
		Commandlet to get an object of type Microsoft.SharePoint.Taxonomy.TermSet from the Taxonomy Store passed in parameter.
		If no Taxonomy Store is passed 'Get-DSPTermStore -Default' will be used by default.

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
		
	.PARAMETER TermStore
		The Term Store where we can find the Term Set.
	
	.PARAMETER GroupName
		The Group of the Term Set.
		
	.PARAMETER TermSetName
		The Term Set to assign to the field.
		
	.EXAMPLE
		PS C:\> Get-DSPTermSet -GroupName "People" -TermSetName "Job Title"

	.OUTPUTS
		Microsoft.SharePoint.Taxonomy.TermSet  
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Get-DSPTermSet()
{
	Param(
		[Parameter(Mandatory=$false,ValueFromPipeline=$true)]
		[Microsoft.SharePoint.Taxonomy.TermStore]$TermStore = $(Get-DSPTermStore -Default),
		
		[Parameter(Mandatory=$true)]
		[string]$GroupName,
		
		[Parameter(Mandatory=$true)]
		[string]$TermSetName
	)
	
  return $TermStore.Groups[$GroupName].TermSets[$TermSetName]
}

function Get-DSPNavigationTermSet()
{
	Param(
		[Parameter(Mandatory=$false,ValueFromPipeline=$true)]
		[Microsoft.SharePoint.Taxonomy.TermStore]$TermStore = $(Get-DSPTermStore -Default),
		
		[Parameter(Mandatory=$false, ValueFromPipeline=$true)]
		[Microsoft.SharePoint.PowerShell.SPSitePipeBind]$Site = $(
			$defaultSite = @(Get-SPWebApplication -IncludeCentralAdministration | Where {$_.IsAdministrationWebApplication})[0].Url
			new-object Microsoft.SharePoint.PowerShell.SPSitePipeBind($defaultSite)
		),
		
		[Parameter(Mandatory=$true)]
		[string]$GroupName,
		
		[Parameter(Mandatory=$true)]
		[string]$TermSetName
	)
	
	$termSet = Get-DSPTermSet -TermStore $termStore -GroupName $GroupName -TermSetName $TermSetName
	return [Microsoft.SharePoint.Publishing.Navigation.NavigationTermSet]::GetAsResolvedByWeb($termSet, $Site.Read().RootWeb, [Microsoft.SharePoint.Publishing.Navigation.StandardNavigationProviderNames]::CurrenCurrentNavigationTaxonomyProvider)
}

<#
	.SYNOPSIS
		Commandlet to create an new Taxonomy Field in the specified web.

	.DESCRIPTION
		Commandlet to create and return a new Taxonomy Field in the specified web.

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
   	 
	.PARAMETER Web
		The web where the field will be created.
		
	.PARAMETER StaticName
		The internal name of the field.
		
	.PARAMETER DisplayName
		The display name of the field.
		
	.PARAMETER FieldGroup
		The Field Group name of the field.
		
	.PARAMETER TermSet
		The Term Set to assign to the field.
		
	.PARAMETER TermStoreGroupName
		The Group of the Term Set.
		
	.PARAMETER TermSetName
		The Term Set to assign to the field.
		
	.PARAMETER TermStore
		The Term Store where we can find the Term Set.

	.EXAMPLE
		PS C:\> New-DSPTaxonomyField -Web "http://example.com/" -DisplayName "Name" -FieldGroup "Group" -StaticName "name" -TermStoreGroupName "People" -TermSetName "Job Title"

	.OUTPUTS
		n/a   
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function New-DSPTaxonomyField()
{
	Param(
		[Parameter(Mandatory=$true, ValueFromPipeline=$true)]
		[Microsoft.SharePoint.PowerShell.SPWebPipeBind]$Web,
		
		[Parameter(Mandatory=$true)]
		[string]$StaticName, 
		
		[Parameter(Mandatory=$true)]
	  [string]$DisplayName,
		
		[Parameter(Mandatory=$true)]
	  [string]$FieldGroup, 
		
		[Parameter(Mandatory=$true, ParameterSetName="TermSet")]
		[Microsoft.SharePoint.Taxonomy.TermSet]$TermSet,
		
		[Parameter(Mandatory=$true, ParameterSetName="GetTermSet")]
	  [string]$TermStoreGroupName,
		
		[Parameter(Mandatory=$true, ParameterSetName="GetTermSet")]
	  [string]$TermSetName,
		
		[Parameter(Mandatory=$false, ParameterSetName="GetTermSet")]
		[Microsoft.SharePoint.Taxonomy.TermStore]$TermStore = $(Get-DSPTermStore -Default)
	)
	
	if ($PsCmdlet.ParameterSetName -eq "GetTermSet") {
			$TermSet = Get-DSPTermSet -TermStore $TermStore -GroupName $TermStoreGroupName -TermSetName $TermSetName
	}
	
	$webSite = $Web.Read()
  $taxonomyField = $webSite.Fields.CreateNewField("TaxonomyFieldType", $DisplayName)

  $taxonomyField.SspId = $TermSet.TermStore.Id
  $taxonomyField.TermSetId = $TermSet.Id
  $taxonomyField.AllowMultipleValues = $false
  $taxonomyField.Group = $FieldGroup
  $taxonomyField.StaticName = $StaticName
  $taxonomyField.ShowInEditForm = $true
  $taxonomyField.ShowInNewForm = $true
  $taxonomyField.Hidden = $false
  $taxonomyField.Required = $false

  $webSite.Fields.Add($taxonomyField);

  $webSite.Update();

  return $taxonomyField
}

<#
	.SYNOPSIS
		Commandlet to set the Term Set to an existing Taxonomy Field.

	.DESCRIPTION
		Commandlet to set the Term Set to an existing Taxonomy Field.

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
   	 
	.PARAMETER Web
		The web where the field is.
		
	.PARAMETER StaticName
		The internal name of the field.
		
	.PARAMETER TermSet
		The Term Set to assign to the field.
		
	.PARAMETER TermStoreGroupName
		The Group of the Term Set.
		
	.PARAMETER TermSetName
		The Term Set to assign to the field.
		
	.PARAMETER TermStore
		The Term Store where we can find the Term Set.

	.EXAMPLE
		PS C:\> Set-DSPTaxonomyField -Web "http://example.com" -StaticName "name" -TermStoreGroupName "People" -TermSetName "Job Title"

	.OUTPUTS
		n/a   
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Set-DSPTaxonomyField()
{
	Param(
		[Parameter(Mandatory=$true, ValueFromPipeline=$true)]
		[Microsoft.SharePoint.PowerShell.SPWebPipeBind]$Web,
		
		[Parameter(Mandatory=$true)]
		[string]$StaticName,
		
		[Parameter(Mandatory=$true, ParameterSetName="TermSet")]
		[Microsoft.SharePoint.Taxonomy.TermSet]$TermSet,
		
		[Parameter(Mandatory=$true, ParameterSetName="GetTermSet")]
	  [string]$TermStoreGroupName,
		
		[Parameter(Mandatory=$true, ParameterSetName="GetTermSet")]
	  [string]$TermSetName,
		
		[Parameter(Mandatory=$false, ParameterSetName="GetTermSet")]
		[Microsoft.SharePoint.Taxonomy.TermStore]$TermStore
	)

  if ($PsCmdlet.ParameterSetName -eq "GetTermSet") {
			$TermSet = Get-DSPTermSet -GroupName $TermStoreGroupName -TermSetName $TermSetName
	}
  
	$webSite = $Web.Read()
  $taxonomyField = [Microsoft.SharePoint.Taxonomy.TaxonomyField]$webSite.Fields.GetFieldByInternalName($StaticName)

    if(!($taxonomyField -eq $null))
    {
      $taxonomyField.SspId = $TermSet.TermStore.Id
      $taxonomyField.TermSetId = $TermSet.Id
      
      $taxonomyField.Update()
    }
    else
    {
        Write-Error "Field $StaticName not found!"
    }
}

<#
	.SYNOPSIS
		Commandlet to set the Term Set to several existing Taxonomy Field defined in an xml file.

	.DESCRIPTION
		Commandlet to set the Term Set to several existing Taxonomy Field defined in an xml file.

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
   
	 .Notes
	 	Here is an example of the xml used as input
	 	<Webs>
			<Web Url="http://example.com">
				<Fields>
					<Field Name="name" Group="People" Term="Job Title" />
				</Fields>
			</Web>
		</Webs>
	 
	.PARAMETER  TermsConfigXml
		The xml definition containing the fields to set.

	.EXAMPLE
		PS C:\> Get-Content 'c:\Fields.xml' | Set-DSPTaxonomyTerms

	.OUTPUTS
		n/a   
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Set-DSPTaxonomyTerms()
{
	Param(
		[Parameter(Mandatory=$true, ValueFromPipeline=$true)]
		[xml]$TermsConfigXml
	)

    $TermsConfigXml.Webs.Web | ForEach-Object
    {
  		$fields = $_.Fields.Field
      [string]$url = $_.Url 
  		
  		$fields | ForEach-Object
      {
  		  Set-DSPTaxonomyField -Web $url -StaticName $_.Name -TermStoreGroupName $_.Group  -TermSetName $_.Term
  		}
    }
}

<#
	.SYNOPSIS
		Commandlet to set an unique term as Taxonomy Value 

	.DESCRIPTION
		Commandlet to set an unique term as Taxonomy Value 

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
   
	.PARAMETER  ListItem
		The List Item
		
	.PARAMETER  ListItem
		The internal name of the column corresponding to the Taxonomy Field

	.PARAMETER  LabelGuidPair
		Label Guid pair of the term (e.g TextLabelValue|GUID)
		
	.EXAMPLE
		PS C:\> Set-TaxonomyFieldValue <ListItemInstance> "MyColumn" MyTerm|f21cdfde-8614-4a60-b047-6ecb4bfb2449

	.OUTPUTS
		n/a   
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Set-DSPTaxonomyFieldValue
{
	Param(
		[Parameter(Mandatory=$true)]
		[Microsoft.SharePoint.SPListItem]$ListItem,
		
		[Parameter(Mandatory=$true)]
		[string]$FieldName,
		
		[Parameter(Mandatory=$true)]
		[string]$LabelGuidPair	
	)

    [Microsoft.SharePoint.Taxonomy.TaxonomyField]$taxonomyField = $ListItem.Fields.GetField($FieldName)
    [Microsoft.SharePoint.Taxonomy.TaxonomyFieldValue]$taxonomyFieldValue = New-Object Microsoft.SharePoint.Taxonomy.TaxonomyFieldValue($taxonomyField)
    $taxonomyFieldValue.PopulateFromLabelGuidPair($LabelGuidPair)
 
    $ListItem[$taxonomyField.Id] = $taxonomyFieldValue;
 
    $ListItem[$taxonomyField.TextField] = $LabelGuidPair
}

<#
	.SYNOPSIS
		Commandlet to set multiple terms as Taxonomy Value 

	.DESCRIPTION
		Commandlet to set multiple terms as Taxonomy Value 

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
   
	.PARAMETER  ListItem
		The List Item
		
	.PARAMETER  ListItem
		The internal name of the column corresponding to the Taxonomy Field

	.PARAMETER  LabelGuidPair
		Label Guid pair of the term separated by a semicolon (e.g TextLabelValue1|GUID1;TextLabelValue2|GUID2)
		
	.EXAMPLE
		PS C:\> Set-TaxonomyFieldMultiValue <ListItemInstance> "MyColumn" "MyTerm1|f21cdfde-8614-4a60-b047-6ecb4bfb2449;MyTerm2|f21cdfde-4694-4a60-dsa1-6ecb4sasab1389"

	.OUTPUTS
		n/a   
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Set-DSPTaxonomyFieldMultiValue
{
	Param(
		[Parameter(Mandatory=$true)]
		[Microsoft.SharePoint.SPListItem]$ListItem,
		
		[Parameter(Mandatory=$true)]
		[string]$FieldName,
		
		[Parameter(Mandatory=$true)]
		[string]$LabelGuidPairs	
	)

    [Microsoft.SharePoint.Taxonomy.TaxonomyField]$taxonomyField = $ListItem.Fields.GetField($FieldName)

    [array]$labelGuidPairFieldValuesArray = $LabelGuidPairs.Split(";")
 
    [Microsoft.SharePoint.Taxonomy.TaxonomyFieldValueCollection]$taxonomyFieldValues = New-Object Microsoft.SharePoint.Taxonomy.TaxonomyFieldValueCollection($taxonomyField)
 
    foreach ($labelGuidPairFieldValue in $labelGuidPairFieldValuesArray)
    {
        [Microsoft.SharePoint.Taxonomy.TaxonomyFieldValue]$taxonomyFieldValue = New-Object Microsoft.SharePoint.Taxonomy.TaxonomyFieldValue($taxonomyField)
        $taxonomyFieldValue.PopulateFromLabelGuidPair($labelGuidPairFieldValue)

        $taxonomyFieldValues.Add($taxonomyFieldValue)
    }
 
    # Set the taxonomy field to contain all of the Taxonomy Field Values
    $ListItem[$taxonomyField.Id] = $taxonomyFieldValues;
 
    $ListItem[$taxonomyField.TextField] = $LabelGuidPairs
}

<#
	.SYNOPSIS
		Commandlet to set delete a term store group and it's containing term sets.

	.DESCRIPTION
		Commandlet to set delete a term store group and it's containing term sets.

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
   	 
	.PARAMETER TermStore
		The Term Store where we can find the Term Group (uses the default term store if none specified).
		
	.PARAMETER GroupName
		The name of the Term Group.

	.EXAMPLE
		PS C:\> Remove-DSPTermGroup -GroupName "People"
		PS C:\> Get-DSPTermStore -Name "Managed Metdata Service" | Remove-DSPTermGroup -GroupName "People"

	.OUTPUTS
		n/a   
    
  .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Remove-DSPTermGroup {
	Param(
		[Parameter(Mandatory=$false,ValueFromPipeline=$true)]
		[Microsoft.SharePoint.Taxonomy.TermStore]$TermStore = $(Get-DSPTermStore -Default),
		
		[Parameter(Mandatory=$true)]
		[string]$GroupName
	)
	
    $group = $TermStore.Groups | where { $_.Name -eq $GroupName }
    if ($group -ne $null) {
      	$group.TermSets | foreach {
			Write-Verbose "Removing term set '$($_.Path)' ..."
    		$_.Delete()
    		$TermStore.CommitAll()
   		}
		
		Write-Host "Removing term group '$($group.Name)' ..."
		$group.Delete()
		$TermStore.CommitAll()
		Write-Host "Done." -ForegroundColor Green
    }
	else {
		Write-Host "Unable to find group with name '$GroupName'." -ForegroundColor Yellow
	}
	  
	$TermStore.CommitAll()
}

<#
    .SYNOPSIS
	    Export a web structure as a taxonomy term set. This cmdlet is compatible with MOSS 2007
	
    .DESCRIPTION
	    Export the web structure under the source web as a XML term set compatible with Gary Lapointe Import-SPTerms cmdlet.
        How the export works:
            - A taxonomy term associated to a web always corresponds to the web welcome page (regardless if it is a publishing site or not).
              All other pages will be placed under this page if a page library exists (/Pages or /SitePages)
            - A term label corresponds to the publishing page Title
            - If variations are enabled on the source web, all target branches will be ignored
            - Page translations are automatically extracted as term labels for the correct language
       
        Be careful, pages with the same name (according to language label) in the same level will be ignored!

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
		
    .PARAMETER SourceWeb
	    [REQUIRED] The source web at which to start exporting. Be careful, if the source web is also a variation root site, all webs under target branches will be ignored.

    .PARAMETER OutputFileName
	    [REQUIRED] The output file name in XML format.

    .PARAMETER TermSetName
	    [REQUIRED] The name of the taxonomy term set

    .PARAMETER ExcludeWeb
	    [OPTIONAL] List of tokens to exclude. Applies on the title and template ID of each web. You can pass an array of string if you have multiple tokens. Regex expressions are supported.
		An all pages in the web are excluded too.

    .PARAMETER ExcludePage
	    [OPTIONAL] List of tokens to exclude. Applies on the title of a single page. You can pass an array of string if you have multiple tokens. Regex expressions are supported.

    .EXAMPLE

        PS C:\> ConvertTo-DSPTaxonomyStructure -SourceWeb "http://<webapp>/sites/site1" -OutputFileName "C:\export.xml" -TermSetName "Navigation" -ExcludeWeb "HomeSubWeb2","STS#1" -ExcludePage "Home"
        PS C:\> Import-SPTerms -ParentGroup $TermGroup -InputFile "C:\export.xml"

        The following structure:

        /Site1
            /Pages
                /HomeSite1.aspx
                /Page1.aspx
                /Folder1
                    /SubPage1.aspx
                /Folder2
            /Subweb1
                /Pages
                    /HomeSubWeb1.aspx
                    /Page2.aspx
            /SubWeb2
                /Pages
                    /HomeSubWeb2.aspx

        Is translated by the taxonomy term set:

        Navigation
            Page 1
            Folder 1
                Sub Page 1
            Folder 2
            Home Sub Web1
                Page 2

	.OUTPUTS
		Here is the output Structure XML schema.

        <!--This file was auto-generated by the ConvertTo-DSPTaxonomyStructure cmdlet at 03/17/2015 10:05:39-->
        <TermSet Id="1be081da-c184-471e-a189-b533c637f084" Name="MyTermSet" IsAvailableForTagging="True">
          <Terms>
            <Term Id="7914f3a7-f848-4649-8e32-fc5e62a6c719" Name="Home">
              <Labels>
                <Label Value="Accueil" Language="1036" IsDefaultForLanguage="False" />
                <Label Value="Home" Language="1033" IsDefaultForLanguage="True" />
              </Labels>
              <Terms>
                <Term Id="b568ec4d-5df2-411c-b239-7d8db031982c" Name="Home">
                  <Labels>
                    <Label Value="Accueil" Language="1036" IsDefaultForLanguage="False" />
                    <Label Value="Home" Language="1033" IsDefaultForLanguage="True" />
                  </Labels>
                  <Terms />
                </Term>
              </Terms>
            </Term>
          </Terms>
        </TermSet>

    .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
#>
function ConvertTo-DSPTaxonomyStructure {
    
    [CmdletBinding()]
	param
	(
		[Parameter(Mandatory=$true, ValueFromPipeline=$true)]
		[string]$SourceWeb,

		[Parameter(Mandatory=$true)]
		[string]$OutputFileName,

        [Parameter(Mandatory=$true)]
		[string]$TermSetName,

        [Parameter(Mandatory=$false)]
		[System.Array]$WebExclusionPatterns,

        [Parameter(Mandatory=$false)]
		[System.Array]$PageExclusionPatterns
    )    

    function Process-Web {
        Param
	    (
            [Parameter(Mandatory=$false)]
            [System.XML.XMLElement]$ParentXMLElement,

		    [Parameter(Mandatory=$true)]
		    [Microsoft.SharePoint.SPWeb]$CurrentWeb,
	
			[Parameter(Mandatory=$false)]
		    [switch]$ExcludePages     
        )      

        $PublishingWeb = [Microsoft.SharePoint.Publishing.PublishingWeb]::GetPublishingWeb($CurrentWeb)
            		
		if ($ExcludePages.IsPresent -eq $false)
		{         
			# If the current web has the publishing feature activated
			if ($PublishingWeb.PagesList -ne $null)
			{
				$RootFolder = $PublishingWeb.PagesList.RootFolder

				# Recursively add taxonomy terms corresponding to pages and folders
				Process-Folder $ParentXMLElement $RootFolder
			}
			else
			{
				# Get the Site Pages
				$SitePagesName = [Microsoft.SharePoint.Utilities.SPUtility]::GetLocalizedString("`$Resources:WikiLibDefaultTitle", "core", $CurrentWeb.RegionalSettings.LocaleId);

				$SitePages = $CurrentWeb.Lists[$SitePagesName]
            
				if ($SitePages)
				{
				   Process-Folder $ParentXMLElement $SitePages.RootFolder
				}
			}
		}

        $AllSubWebs = $CurrentWeb.Webs

        # Process all sub webs
        if ($AllSubWebs -ne $null)
        {
            # Exclusion conditions
            # - The web is a variation root site (i.e /en, /fr)
            # - The web is not in the source variation branch
            # - The web title or template ID matches one or more explicit exclusion tokens
            $AllSubWebs | ForEach-Object {
               
                $IsExcluded = $false
                $SubWeb = $_
				$SubWebTemplateId = $SubWeb.WebTemplate + "#" + $SubWeb.Configuration

                # We need to use a different variable name because of PowerShell variable scope
                # Reusing ParentXMLElement causes an ambigous call in PowerShell due to recursivity context
                $SubWebParentXMLElement = $ParentXMLElement

                $PublishingSubWeb = [Microsoft.SharePoint.Publishing.PublishingWeb]::GetPublishingWeb($SubWeb)
                $WebTermLabels = @{}
                    
                if ($IsVariationsEnabled)
                {
                    # Exclude variation root sites and sites where are not is the source variation branch
                    if([System.IO.Path]::GetFileNameWithoutExtension($_.ServerRelativeUrl) -ne $PublishingSubWeb.Label.Title -and $PublishingSubWeb.Label.IsSource)
                    {
						if ($PublishingSubWeb.VariationPublishingWebUrls -ne $null)
						{
							# Get all peers URL
							$PublishingSubWeb.VariationPublishingWebUrls | ForEach-Object {
                        
								$PeerSite = New-Object Microsoft.SharePoint.SPSite($_)
								$PeerWeb = $PeerSite.OpenWeb()
								$PeerPublishingWeb = [Microsoft.SharePoint.Publishing.PublishingWeb]::GetPublishingWeb($PeerWeb)
								$WebTermLabels.Add($PeerWeb.Locale.LCID, $PeerPublishingWeb.DefaultPage.Title)

								$PeerWeb.Dispose()
								$PeerSite.Dispose();
							}
						}
                    }
                    else
                    {
                        $IsExcluded = $true
                    }
                }

                # Check exclusion regex patterns
                if ($WebExclusionPatterns -ne $null)
                {
                    if ((($SubWeb.Title | Select-String -Pattern $WebExclusionPatterns) -ne $null) -or (($SubWebTemplateId | Select-String -Pattern $WebExclusionPatterns) -ne $null))
                    {
                        $Url =$SubWeb.Url
                        $Title = $SubWeb.Title
                        $Tokens = $WebExclusionPatterns -Join ","
                        Write-Warning "Web '$Url' with title '$Title' and template '$SubWebTemplateId' matches one of exclusion tokens '$Tokens'. Skipping..."
                        $IsExcluded = $true
                    }
                }
                
                # If the current sub web doesn't meet exclusion conditions, create a term node <Term> and add <Terms> sub nodes to potentially allow sub nodes above
                if ($IsExcluded -eq $false)
                {
					if ($PublishingSubWeb.DefaultPage -ne $null)
					{
						# If the site is not a publishing site, we need to get the defaut page item in the site pages library
						if ($PublishingSubWeb.DefaultPage.Title -eq $null)
						{
							# [Microsoft.SharePoint.Utilities.SPUtility]::ConcatUrls() doesn't exist in MOSS 2007 ;)
							$PageUrl = [Microsoft.SharePoint.Utilities.SPUtility]::GetFullUrl($SubWeb.Site, $PublishingSubWeb.DefaultPage.ServerRelativeUrl)
							$PeerSite = New-Object Microsoft.SharePoint.SPSite($PublishingSubWeb.Url)
							$PeerWeb = $PeerSite.OpenWeb()
							$PeerPage =$PeerWeb.GetListItem($PageUrl)

							$WebTermLabel = $PeerPage.DisplayName 

							$PeerWeb.Dispose()
							$PeerSite.Dispose();
						}
						else
						{
							# We use the default page of the web as corresponding taxomomy term node
							$WebTermLabel = $PublishingSubWeb.DefaultPage.Title  
						}

						$WebTermLabels.Add($SubWeb.Locale.LCID, $WebTermLabel)

						$SubWebParentXMLElement = New-XMLSingleTermNode $ParentXMLElement $WebTermLabels $SubWeb $SubWeb.Url
						$TermsXMLNode = New-XMLTermsNode $SubWebParentXMLElement  
						$SubWebParentXMLElement = $TermsXMLNode
					}
					else
					{	
						# Unable to determine a welcome page for the web,. Maybe the web template is a blank site (STS#1) or a funky typed site (SPS#0, etc..)
						# In these cases, we simply ignore the web. It would be too difficult to get the right welcome page for each specific web template
						$SubWebUrl = $PublishingSubWeb.Url
						Write-Warning "The web '$SubWebUrl' with template '$SubWebTemplateId' doesn't seem to support pages system. Skipping..."
					}

					# Process elements in the subweb either if the root node is its home page or if it is the original parent (means the web is excluded)
					Process-Web $SubWebParentXMLElement $_
                }
				else
				{
					# Process the web but exclude its pages
					Process-Web $SubWebParentXMLElement $_ -ExcludePages
				}
            }
        }       
    }

    function Process-Folder { 
        
        Param
	    (
            [Parameter(Mandatory=$false)]
            [System.XML.XMLElement]$ParentXMLElement, 
        
		    [Parameter(Mandatory=$true)]
		    [Microsoft.SharePoint.SPFolder]$Folder
        ) 
     
        $List = $Folder.ParentWeb.Lists[$Folder.ParentListId]
        $ParentWeb = $Folder.ParentWeb

        # Get all items excluding the folder welcome page (including team site welcome page type)
        $CamlQuery = New-Object -TypeName Microsoft.SharePoint.SPQuery
        $CamlQuery.Query = "<OrderBy><FieldRef Name='Title'/></OrderBy>"
        $CamlQuery.Folder = $Folder

        $LabelItems = $List.GetItems($CamlQuery)  | Where-Object { ($_.Name -ne $Folder.WelcomePage) -and ($_.Url -ne $ParentWeb.RootFolder.WelcomePage) }

        if ($LabelItems -ne $null)
        { 
            $LabelItems | ForEach-Object {
                
                if ($_.Folder -ne $null)
                {       
                    # If there is a welcome page for the folder, get the corresponding publishing page
                    if ([string]::IsNullOrEmpty($_.Folder.WelcomePage) -eq $false)
                    {
                        # Get the publishing page corresponding to the folder welcome page
                        # We can't use $PublishingWeb.GetPublishingPage($_.ID) here because of MOSS 2007 compatibility
                        $PageQuery = New-Object -TypeName Microsoft.SharePoint.SPQuery
                        $PageQuery.Query = "<Where><Eq><FieldRef Name='FileLeafRef'/><Value Type='Text'>" + $_.Folder.WelcomePage + "</Value></Eq></Where><OrderBy><FieldRef Name='Title' /></OrderBy>"
                        $PageQuery.Folder = $_.Folder
                        $PageQuery.ViewAttributes = "Scope='RecursiveAll'"
                        $PageQuery.RowLimit = 1

                        $WelcomePublishingPage  = $PublishingWeb.GetPublishingPages($PageQuery)
                        $FolderParentXMLElement = Process-Page $ParentXMLElement $WelcomePublishingPage[0]
                    }
                    else
                    {
                        # If there isn't a welcome page for the current folder we use the folder name
                        # Be careful, translations of folders are not maintained by the variation system
                        $FolderTermLabels = @{}
                        $FolderTermLabels.Add($Folder.ParentWeb.Locale.LCID, $_.Folder.Name)

                        $FolderParentXMLElement = New-XMLSingleTermNode $ParentXMLElement $FolderTermLabels $ParentWeb $_.Folder.Url
                    }

                    $TermsXMLNode = New-XMLTermsNode $FolderParentXMLElement    
                    Process-Folder $TermsXMLNode $_.Folder
                } 
                else
                {
                    Process-Page $ParentXMLElement $_   
                }
            }
        }       
    }

    function Process-Page {

        Param
	    (
            [Parameter(Mandatory=$false)]
            [System.XML.XMLElement]$ParentXMLElement,

		    [Parameter(Mandatory=$true)]
		    [Microsoft.SharePoint.SPListItem]$PageItem   
        )       

        $PageTermLabels = @{}
        $IsExcluded = $false
		$ParentWeb = $PageItem.ParentList.ParentWeb
		$PageTermLabel = $PageItem.Title

        # Wiki pages don't have a title property but publishing pages do
        if ([string]::IsNullOrEmpty($PageTermLabel))
        {
            $PageTermLabel = $PageItem.DisplayName

			# Finally, if the title is null, we take the item name (cannot be null)
			if ($PageTermLabel -eq $null)
			{
				$PageTermLabel = $PageItem.Name
			}
        }

        # Check exclusion regex patterns
        if ($PageExclusionPatterns -ne $null)
        {
            if ((($PageTermLabel | Select-String -Pattern $PageExclusionPatterns) -ne $null) -or (($PageItem.Name | Select-String -Pattern $PageExclusionPatterns) -ne $null))
            {
                $Tokens = $PageExclusionPatterns -Join ","
                Write-Warning "Page with title '$PageTermLabel' matches one of exclusion tokens '$Tokens'. Skipping..."
                $IsExcluded = $true
            }
        }
         
        if ($IsExcluded -eq $false)
        {
			$PublishingWeb = [Microsoft.SharePoint.Publishing.PublishingWeb]::GetPublishingWeb($ParentWeb)

            $Locale = $PageItem.Web.Locale.LCID
            $PageTermLabels.Add($Locale, $PageTermLabel)

            if ($IsVariationsEnabled -and $PublishingWeb.PagesList -ne $null)
            {
                # If variations are enabled, the page is necessarily a publishing page
                # We can't use $PublishingWeb.GetPublishingPage($_.ID) here because of MOSS 2007 compatibility
                $PageQuery = New-Object -TypeName Microsoft.SharePoint.SPQuery
                $PageQuery.Query = "<Where><Eq><FieldRef Name='ID'/><Value Type='Counter'>" + $_.ID + "</Value></Eq></Where><OrderBy><FieldRef Name='Title' /></OrderBy>"
                $PageQuery.Folder = $PublishingWeb.PagesList.RootFolder
                $PageQuery.ViewAttributes = "Scope='RecursiveAll'"
                $PageQuery.RowLimit = 1

				# Be careful, the return type is  Microsoft.SharePoint.Publishing.PublishingPageCollection
                $PublishingPage = $PublishingWeb.GetPublishingPages($PageQuery)

				if ($PublishingPage)
				{
					$VariationLabels = $PublishingPage[0].VariationPageUrls
					if ($VariationLabels -ne $null)
					{
						# Check peer pages in target variations branches
						$VariationLabels | ForEach-Object {

							$PeerSite = New-Object Microsoft.SharePoint.SPSite($_)
							$PeerWeb = $PeerSite.OpenWeb()
							$PeerPage = $PeerWeb.GetListItem($_)
							$PeerPageTermLabel = $PeerPage.Title

							# Wiki pages don't have a title property but publishing pages do
							if ([string]::IsNullOrEmpty($PeerPageTermLabel))
							{
								$PeerPageTermLabel = $PageItem.DisplayName

								# Finally, if the title is null, we take the web title
								if ($PeerPageTermLabel -eq $null)
								{
									$PeerPageTermLabel = $PeerPage.Name
								}
							}

							$PageTermLabels.Add($PeerWeb.Locale.LCID, $PeerPageTermLabel)
                
							$PeerWeb.Dispose()
							$PeerSite.Dispose()
						}
					}
				}	
			}

            $PageXMLElement = New-XMLSingleTermNode $ParentXMLElement $PageTermLabels $PageItem.Web $PageItem.Url
        }

        return $PageXMLElement  
    }

    function New-XMLTermsNode {

        Param
	    (
            [Parameter(Mandatory=$false)]
            [System.XML.XMLElement]$ParentXMLElement      
        )

        # Ex: <Terms>
        [System.XML.XMLElement]$TermsXMLElement = $XMLDocument.CreateElement("Terms")
        [void]$ParentXMLElement.appendChild($TermsXMLElement)

        return $TermsXMLElement
    }

    function New-XMLSingleTermNode {

        Param
	    (
            [Parameter(Mandatory=$false)]
            [System.XML.XMLElement]$ParentXMLElement,

            [Parameter(Mandatory=$true)]
            [hashtable]$Labels,

		    [Parameter(Mandatory=$true)]
		    [Microsoft.SharePoint.SPWeb]$AssociatedWeb,

            [Parameter(Mandatory=$true)]
		    [string]$AssociatedItemPath
        )    

        New-XMLComment $ParentXMLElement "Associated element: '$AssociatedItemPath'"

        [System.XML.XMLElement]$TermXMLElement= $XMLDocument.CreateElement("Term")		

        # In the Import-SPTerms cmdlet, the guid doesn't matter
        [void]$TermXMLElement.SetAttribute("Id", [guid]::NewGuid())
        
        [System.XML.XMLElement]$LabelsXMLElement= $XMLDocument.CreateElement("Labels")

        $Labels.Keys | ForEach-Object  {
			
			$Label = $Labels.Get_Item($_)
			$Language = $_

			# Replace encoded characters ($quot; $amp; etc.) with real values
			$Label = [System.Web.HttpUtility]::HtmlDecode($Label)

			# Trim Special characters not allowed for a term label (;"<>|&tab)
			# See https://msdn.microsoft.com/en-us/library/office/ee565922.aspx
		
			$Label = $Label -replace '[;"<>|\t]+',[string]::Empty

			# Trim consecutive whitespaces
			$Label = $Label -replace '\s+', ' '
				
			# Check if a similar node is present at the same level (Terms node)
			# SharePoint taxonomy term set does not allow duplicate labels for a language at the same level
			$duplicateNodes = $ParentXMLElement.SelectNodes(".//Label") | Where-Object { ($_.Value -eq $Label) -and ($_.Language -eq $Language) }

			if ($duplicateNodes -eq $null)
			{
				[System.XML.XMLElement]$LabelXMLElement= $XMLDocument.CreateElement("Label")
            
				# Ex: <Label Value="MyTerm" Language="1033" IsDefaultForLanguage="True" />
				[void]$LabelXMLElement.SetAttribute("Value", $Label)
				[void]$LabelXMLElement.SetAttribute("Language", $Language)

				if ($AssociatedWeb.Locale.LCID -eq $_)
				{
					$DefaultName = $Label
				}
            
				# Always set the label as default language
				[void]$LabelXMLElement.SetAttribute("IsDefaultForLanguage", "True") 
				[void]$LabelsXMLElement.appendChild($LabelXMLElement)
			}
			else
			{	
				Write-Warning "Label '$Label' already exists!"
			}
        }

		# If there is at least one label for the term
		if ($DefaultName -ne $null)
		{
			$TermXMLElement.SetAttribute("Name", $DefaultName)

			[void]$TermXMLElement.appendChild($LabelsXMLElement)
			[void]$ParentXMLElement.appendChild($TermXMLElement)    
		}
		else
		{
			New-XMLComment $ParentXMLElement "Ignored"
		}
        
        return $TermXMLElement
    }

    function New-XMLComment {
        
        Param
	    (
            [Parameter(Mandatory=$false)]
            [System.XML.XMLElement]$ParentXMLElement,  

            [Parameter(Mandatory=$false)]
            [string]$Comment     
        )

		# Normalize comment
		# https://msdn.microsoft.com/en-us/library/bb514668%28v=vs.90%29.aspx
		$Comment =  $Comment.Replace("--", [string]::Empty)

        [System.XML.XmlComment]$CommentElement = $XMLDocument.CreateComment($Comment)
        [void]$ParentXMLElement.appendChild($CommentElement)
    }

    # Load SharePoint assembly to be backward compatible with MOSS 2007
    [void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SharePoint")
	[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SharePoint.Publishing")
    Try
    {
        $Site = New-Object Microsoft.SharePoint.SPSite($SourceWeb)
        $Web = $Site.OpenWeb()

        if($Web.IsRootWeb)
        {
            $RootWeb = $Web
        }
        else
        {
            $RootWeb = $Web.Site.RootWeb
        }   
        
        # Check variations settings on the root web of the site collection of the current web
        $VariationLabels =  $RootWeb | Get-VariationLabels

        if( $VariationLabels.Count -gt 0)
        {
            $IsVariationsEnabled = $true
        }
        else
        {
            $IsVariationsEnabled = $false
        }

        # Create a new XML File
        [System.Xml.XmlDocument]$XMLDocument = New-Object System.Xml.XmlDocument
        $XmlDeclaration = $XMLDocument.CreateXmlDeclaration("1.0","UTF-8",$null)
        $XMLDocument.appendChild($XmlDeclaration)

        # Write header
        $XMLHeader = $XMLDocument.CreateComment("This file was auto-generated by the ConvertTo-DSPTaxonomyStructure cmdlet at "+ (Get-Date))
        $XMLDocument.AppendChild($XMLHeader)

        # Create the root node (an XML file must have a root node even if there is no web to export)
        [System.XML.XMLElement]$RootXMLElement= $XMLDocument.CreateElement("TermSet")
        [void]$RootXMLElement.SetAttribute("Id", [guid]::NewGuid())
        [void]$RootXMLElement.SetAttribute("Name", $TermSetName)
        [void]$RootXMLElement.SetAttribute("IsAvailableForTagging", "True")
        $XMLDocument.appendChild($RootXMLElement)

        # Recursively create nodes
        $RootXMLElement = New-XMLTermsNode $RootXMLElement
        Process-Web $RootXMLElement $Web

        # Create StreamWriter for encoding
        $StreamWriter = New-Object System.IO.StreamWriter($OutputFileName, $false, [System.Text.Encoding]::UTF8)

        # Save File
        $XMLDocument.Save($StreamWriter)

        $StreamWriter.Close()
        $RootWeb.Dispose()
        $Site.Dispose();
    }
    Catch
    {
        $ErrorMessage = $_.Exception.Message
        throw $ErrorMessage
    }
}